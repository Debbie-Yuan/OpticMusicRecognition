import colorsysimport jsonimport tempfileimport timefrom os import listdir, mkdirfrom os.path import join, split, splitext, isdir, existsfrom random import randintfrom typing import Tuple, Listimport numpy as npimport pymusicxml as pmlfrom PIL import Image, ImageDraw, ImageFontfrom PyQt5.QtCore import pyqtSignal, QObjectfrom models import PIC2SECModelfrom models import SEC2TSModelfrom models import TSRecfrom mxml import Convertorfrom settings import TEMPclass Phase(QObject):    def __init__(self, **kwargs):        super(Phase, self).__init__()        self.outer_status = kwargs.get('status', [True])        self.log = []    def get_log(self):        return ''.join(self.log)    def clear_log(self):        self.log.clear()    def print_to_log(self, msg, print_=False, end_with_enter=True):        self.log.append(msg + '\n')        if print_:            print(msg, end='\n' if end_with_enter else '')    def __call__(self, *args, **kwargs):        pass    @staticmethod    def create_temp_folder() -> tempfile.TemporaryDirectory:        dirname = tempfile.TemporaryDirectory(dir=TEMP)        return dirname    @staticmethod    def create_temp_file(dir, suffix=''):        _, fn = tempfile.mkstemp(suffix=suffix, dir=dir)        return fn    @staticmethod    def list_dir(dir):        return [join(dir, i) for i in listdir(dir)]    @staticmethod    def get_fp_fn(abs_pth):        return split(abs_pth)    @staticmethod    def get_fn_ext(fn):        return splitext(fn)    @staticmethod    def generate_task(dir, p=1):        if p == 1:            fn = '.p1meta.txt'        else:            fn = '.p2meta.txt'        with open(join(dir, fn), 'r') as fp:            for line in fp.readlines():                yield line.strip('\n')    @staticmethod    def walk_through_all_folders(dir):        for i in listdir(dir):            if isdir(join(dir, i)):                yield i    @staticmethod    def image_crop(image, left, top, right, bottom):        l_ = left - 7 if left - 7 >= 0 else 0        t = top - 5 if top - 5 >= 0 else 0        mr, mb = image.width, image.height        r = right + 7 if right + 7 <= mr else mr        b = bottom + 5 if bottom + 5 <= mb else mb        return image.crop(box=(l_, t, r, b))    def load_image(self, image_pth):        self.print_to_log(f'[GD Phase] Loading image `{image_pth}`...')        image = Image.open(image_pth)        ret = image.convert('RGB')        self.print_to_log(f'[GD Phase] Image Loaded Successfully!')        return ret    @staticmethod    def suffix(base, t, fmt):        return f'{base}@{t}{fmt}'    @staticmethod    def create_folder(base, fn):        folder = join(base, fn)        try:            mkdir(folder)            return folder        except FileExistsError:            return folder    def run(self):        self()    def emit(self, a, b):        self.iter_callback.emit(a, b, self.get_log())        self.clear_log()    def check_outer_status(self):        if False in self.outer_status:            return True        return False    def leave(self):        self.outer_status.append(False)class PhaseOne(Phase):    """        功能： 给出一张图像，将其按照网络结果分割，并保存所有输出图像。        另外，应该保存用户输入的所有元信息，如这个乐谱的谱号，作者、拍速、等信息。    """    '''        0,0 ------> x (width)         |         |  (Left,Top)         |      *_________         |      |         |                |         |         y      |_________|      (height)            *                    (Right,Bottom)    '''    iter_callback = pyqtSignal(int, int, str)    def __init__(self, image_pth, **kwargs):        super(PhaseOne, self).__init__(**kwargs)        self.model = PIC2SECModel        self.temp_dir = self.create_temp_folder()        self.image_pth = image_pth        self.failed = False        try:            self.image = self.load_image(image_pth)        except FileNotFoundError:            self.failed = True        self.ob = None        self.os = None        self.oc = None        self.draw_img = None        hsv_tuples = [(x / 7, 1., 1.)                      for x in range(7)]        self.colors = list(map(lambda x: colorsys.hsv_to_rgb(*x), hsv_tuples))        self.colors = list(            map(lambda x: (int(x[0] * 255), int(x[1] * 255), int(x[2] * 255)),                self.colors))    def _extract(self):        extract_idx = [t for t, i in enumerate(self.oc) if i == 1]        extract_obs = [(int(self.ob[i][1]), int(self.ob[i][0]), int(self.ob[i][3]), int(self.ob[i][2]))                       for i in extract_idx]        return extract_idx, extract_obs    @staticmethod    def is_inline(ob, line: List or Tuple) -> bool:        """            要判断一个箱形元素与其它元素是否在一条直线上，只需要判断这个元素的一个y轴边长范围与某一条线中其它所有元素是否有相交80%以上区域即可            给定一个ob, 一个obj in line，且obj(left， top， right， bottom)                只需计算height_down<-min(obj[3], ob[3])确定两个元素的最高下界限与height_up<-max(obj[1], ob[1])确定两个元素的                最低上界限，计算bound_down <- max(obj[3], ob[3])计算bound_up <- min(obj[1], ob[1])                计算比例： ISR (Intersection Rate) = (height_down - height_up) / (bound_down - bound_up)                判断ISR>0.8，即返回True            循环结束没有返回，即返回False        """        for obj in line:            height_down = min(ob[3], obj[3])            height_up = max(ob[1], obj[1])            bound_down = max(ob[3], obj[3])            bound_up = min(ob[1], obj[1])            isr = (height_down - height_up) / (bound_down - bound_up)            if isr > 0.6:                return True        return False    def sort_with_coordinates(self, obs_extracted: Tuple or List) -> dict:        # 从无序的列表中选出行中元素        row_dict = {}        start_cursor = 0        # 遍历每一个属于section的类        for ob in obs_extracted:            #  将它与当前字典中的行进行匹配            ob_caught = False  # 表示当前是否被捕获            for k in row_dict.keys():                #  若匹配则加入行                if self.is_inline(ob, row_dict[k]):                    row_dict[k].append(ob)                    # 当前被捕获                    ob_caught = True                    break            #  若未能匹配，则将其新开一行加入            if not ob_caught:                row_dict.setdefault(start_cursor, [ob, ])                start_cursor += 1        # 从无序的行中根据y<-(ob[2] + ob[0]) / 2值进行        for k in row_dict.keys():            row_dict[k] = sorted(row_dict[k], key=lambda x: (x[2] + x[0]) / 2)        row_sorted_dict = {}        row_tmp = []        for val in row_dict.values():            avg_height = sum(                ((v[3] + v[1]) / 2 for v in val)            ) / len(val)            row_tmp.append((avg_height, val))        sorted_row_tmp = sorted(row_tmp, key=lambda x: x[0])        cnt = 0        for val in sorted_row_tmp:            row_sorted_dict.setdefault(cnt, val[1])            cnt += 1        return row_sorted_dict    def show_sorted_with_image(self, res: dict):        __tag__ = 'left, top, right, bottom'        image_copy = self.image.copy()        font = ImageFont.truetype(            font='/Users/daipeiyuan/developer/PyCharm/graduation_design/models/yolov4_c/font/simhei.ttf',            size=8)        thickness = max((self.image.size[0] + self.image.size[1]) // 300, 1)        for i, c in res.items():            for t, box in enumerate(c):                # top, left, bottom, right = box                left, top, right, bottom = box                top = top - 5                left = left - 5                bottom = bottom + 5                right = right + 5                top = max(0, np.floor(top + 0.5).astype('int32'))                left = max(0, np.floor(left + 0.5).astype('int32'))                bottom = min(self.image.size[1], np.floor(bottom + 0.5).astype('int32'))                right = min(self.image.size[0], np.floor(right + 0.5).astype('int32'))                # 画框框                label = '{}@{}行-{}列'.format(box, i, t)                draw = ImageDraw.Draw(image_copy)                label_size = draw.textsize(label, font)                label = label.encode('utf-8')                # print(label, top, left, bottom, right)                if top - label_size[1] >= 0:                    text_origin = np.array([left, top - label_size[1]])                else:                    text_origin = np.array([left, top + 1])                for _i in range(thickness):                    draw.rectangle(                        [left + _i, top + _i, right - _i, bottom - _i],                        outline=self.colors[randint(0, 6)])                draw.rectangle(                    [tuple(text_origin), tuple(text_origin + label_size)],                    fill=self.colors[randint(0, 6)])                draw.text(text_origin, str(label, 'UTF-8'), fill=(0, 0, 0), font=font)                del draw        return image_copy    def __call__(self, *args, **kwargs):        self.print_to_log('[GD PhaseOne] Predicting...')        self.draw_img, self.ob, self.os, self.oc = self.model.detect_image(self.image)        self.print_to_log(f'[GD PhaseOne] Predict Finished with {len(self.oc)}')        self.print_to_log('[GD PhaseOne] Extracting...')        extract_idx, extract_obs = self._extract()        sorted_res = self.sort_with_coordinates(extract_obs).values()        sorted_arr = [j for i in sorted_res for j in i]        self.print_to_log('[GD PhaseOne] Extract & Sort Finished!')        base_fn, fmt = self.get_fn_ext(self.get_fp_fn(self.image_pth)[-1])        with open(join(self.cwd, '.p1meta.txt'), 'w') as meta:            for t, i in enumerate(sorted_arr):                cropped = self.image_crop(self.image, *i)                tfn = self.create_temp_file(self.cwd, self.suffix(base_fn, t, fmt))                cropped.save(tfn)                meta.write(f"{tfn}\n")                self.emit(t + 1, len(extract_idx))                # 检查是否需要退出                if self.check_outer_status():                    return -1    def run(self):        self()        if self.draw_img:            self.draw_img.save(join(self.temp_dir.name, 'p1-net-res.jpg'))        if self.image:            self.image.save(join(self.temp_dir.name, 'p1-origin.jpg'))    @property    def cwd(self):        return self.temp_dir.nameclass PhaseTwo(Phase):    iter_callback = pyqtSignal(int, int, str)    def __init__(self, d: tempfile.TemporaryDirectory, **kwargs):        super(PhaseTwo, self).__init__(**kwargs)        self.model = SEC2TSModel        self.temp_dir = d        self.image_pth = None        self.ob = None        self.os = None        self.oc = None        self.draw_img = None    def _extract(self):        extract_idx = [t for t, i in enumerate(self.oc) if i == 0]        extract_obs = [(int(self.ob[i][1]), int(self.ob[i][0]), int(self.ob[i][3]), int(self.ob[i][2]))                       for i in extract_idx]        return extract_idx, extract_obs    def __call__(self, *args, **kwargs):        tasks = tuple(self.generate_task(self.cwd))        length = len(tasks)        for times, task in enumerate(tasks):            # 为每一个task创建文件夹，进入文件夹            dir, fn = self.get_fp_fn(task)            fnl, ext = self.get_fn_ext(fn)            print(dir, fn, fnl, ext)            folder = self.create_folder(dir, fnl)            print(folder)            self.print_to_log(f'[GD PhaseTwo] Loading task `{fnl}`, create folder `{folder}`...')            # 加载图像            image = self.load_image(task)            self.print_to_log('[GD PhaseTwo] Predicting...')            # 预测            self.draw_img, self.ob, self.os, self.oc = self.model.detect_image(image)            self.print_to_log(f'[GD PhaseOne] Predict Finished with {len(self.oc)}')            # 解析预测值            self.print_to_log('[GD PhaseTwo] Extracting...')            extract_idx, extract_obs = self._extract()            extract_obs = sorted(extract_obs, key=lambda x: (x[2] + x[0]) / 2)            self.print_to_log('[GD PhaseTwo] Extract & Sort Finished!')            # 写入预测结果            with open(join(folder, '.p2meta.txt'), 'w') as meta:                for t, i in enumerate(extract_obs):                    cropped = self.image_crop(image, *i)                    tfn = self.create_temp_file(folder, self.suffix(fnl, t, ext))                    cropped.save(tfn)                    meta.write(f"{tfn}\n")                    # 检查是否需要退出                    if self.check_outer_status():                        return -1            if self.draw_img:                self.draw_img.save(join(folder, 'p2-net-res.jpg'))            if image:                image.save(join(folder, 'p2-origin.jpg'))            self.emit(times + 1, length)    def run(self):        self()    @property    def cwd(self):        if isinstance(self.temp_dir, tempfile.TemporaryDirectory):            return self.temp_dir.name        return self.temp_dirclass PhaseThree(Phase):    iter_callback = pyqtSignal(int, int, str)    def __init__(self, d, **kwargs):        super(PhaseThree, self).__init__(**kwargs)        self.model = TSRec        self.temp_dir = d    def __call__(self, *args, **kwargs):        # 统计        total_tsk = 0        for folder in self.walk_through_all_folders(self.cwd):            folder_abs = join(self.cwd, folder)            for _ in self.generate_task(folder_abs, p=2):                # 检查是否需要退出                if self.check_outer_status():                    return -1                total_tsk += 1        for folder in self.walk_through_all_folders(self.cwd):            self.print_to_log(f"[GD PhaseThree] Entering folder `{folder}`...")            folder_abs = join(self.cwd, folder)            cnt = 0            with open(join(folder_abs, 'p3res.txt'), 'w') as p3res:                for task in self.generate_task(folder_abs, p=2):                    vector, classes = self.model.predict(task, verbose=True, print_func=self.print_to_log)                    str_classes = [str(i) for i in classes]                    # 保存                    p3res.write(f"{' '.join(str_classes)}\n")                    cnt += 1                    self.emit(cnt + 1, total_tsk)                    # 检查是否需要退出                    if self.check_outer_status():                        return -1            self.print_to_log(f"[GD PhaseThree] Leave folder with {cnt} item parsed.")    def run(self):        self()    @property    def cwd(self):        if isinstance(self.temp_dir, tempfile.TemporaryDirectory):            return self.temp_dir.name        return self.temp_dirclass Compose(Phase):    """        功能： 给出一个指定的文件夹，以及用户输入的信息。            首先遍历每个文件夹，并以文件夹的@值作为字典key                进入文件夹，并从文件夹中同时读取p2meta与p3res, 读取最后一个@值作为内部字典key， p3res经过列表化后将其对应Convertor处理                得到一个Json文件，最终按照Json文件解析为XML    """    iter_callback = pyqtSignal(int, int, str)    def __init__(self, temp_dir: [str or tempfile.TemporaryDirectory], **kwargs):        super(Compose, self).__init__()        self.working_dir = temp_dir        self.title = kwargs.get('title', '')        self.author = kwargs.get('author', '')        self.clef = kwargs.get('clef', tuple())        self.speed = kwargs.get('speed', 80)        self.parts = kwargs.get('parts', 1)        self.time_signature = kwargs.get('time_signature', (4, 4))        # clef handler        if len(self.clef) == 1:            if self.clef == 'g':                Convertor.set_g_clef()            else:                Convertor.set_f_clef()    def __call__(self, *args, **kwargs):        return self.compose_to_score(**kwargs)    def _extract_from_temp_dir(self) -> dict:        res = {}        for section in self.walk_through_all_folders(self.cwd):            # 创建元素存储位置            sec_id = int(section.split('@')[-1])            # 进入文件夹            abs_folder = join(self.cwd, section)            # 处理空行            cls = [line.strip('\n') for line in open(join(abs_folder, 'p3res.txt'), 'r').readlines() if line != '\n']            # 按行解析元素            inner_res = []            for i in range(len(cls)):                try:                    int_cls = tuple((int(j) for j in cls[i].split(' ')))                    note_obj = Convertor(int_cls)                    inner_res.append(note_obj)                    # 检查是否需要退出                    if self.check_outer_status():                        return -1                except ValueError:                    self.print_to_log(" ".join((sec_id, i, abs_folder)))            # 将section信息保存至section字典中            res.setdefault(sec_id, inner_res)        return res    def save_result_to_file(self, res, dir=None):        assert isinstance(res, dict)        json_like = json.dumps(res, sort_keys=True, indent=4, separators=(',', ': '))        if dir and exists(dir):            fn = join(dir, f"{int(time.time())}.json")        else:            if not exists(dir):                self.print_to_log('[GD COMPOSER - JSON] [WARNING] Dir not exist.')            fn = join(self.cwd, f"{int(time.time())}.json")        with open(fn, 'wt') as json_fp:            json_fp.write(json_like)        self.print_to_log('[GD COMPOSER] Json file saved successfully!.')    def compose_to_score(self, **kwargs) -> Tuple[pml.Score, int, int]:        save_json = kwargs.get('save_json', True)        export_dir = kwargs.get('export_dir', None)        json_like_res = self._extract_from_temp_dir()        max_key = max(json_like_res.keys())        # 建立一个score对象        score = pml.Score(title=self.title, composer=self.author)        part = pml.Part("Piano")        # TODO 建立一个CMP对象        # cmp_score = cmp.Score(title=self.title, composer=self.author)        # cmp_measures = list()        # cmp_part = cmp.Staff(cmp_measures, name='piano')        # cmp_measure = cmp.Measure()        # cmp_voice = cmp.NoteLike()        # 记录成功与失败标识        succeed, failed = 0, 0        for i in range(max_key + 1):            measure = pml.Measure(time_signature=self.time_signature)            measure_content = json_like_res[i]            for ts in measure_content:                # 若这个音符不清楚，则需要跳过并继续                if ts.get('clear') is False:                    failed += 1                    continue                # 根据dot测量speed                speed = ts.get('speed')                if ts.get('dot'):                    speed = speed * 1.5                # 判断休止符                if ts.get('rest'):                    measure.append(pml.Rest(speed))                    succeed += 1                    continue                # 不是休止符即为普通音符                if ts.get('up'):                    handler = Convertor.sharpen_note                elif ts.get('down'):                    handler = Convertor.lower_note                else:                    def _(x):                        return x                    handler = _                notes = ts.get('notes')                if len(notes) > 1:                    n = pml.Chord(tuple((handler(note) for note in ts.get('notes'))), duration=speed)                else:                    n = pml.Note(notes[0], duration=speed)                # 检查是否需要退出                if self.check_outer_status():                    return None, -1, -1                measure.append(n)                succeed += 1            # 加入每个部分            if len(measure.contents) == 0:                continue            part.append(measure)            self.emit(1, max_key + 1)        if save_json:            self.save_result_to_file(json_like_res, export_dir if export_dir else self.cwd)        score.append(part)        return score, succeed, failed    def run(self):        return self.compose_to_score(save_json=True)    @property    def cwd(self):        if isinstance(self.working_dir, tempfile.TemporaryDirectory):            return self.working_dir.name        return self.working_dir# if __name__ == '__main__':#     # composer = Compose("/Users/daipeiyuan/developer/PyCharm/graduation_design/temp/tmpza8z7tba",#     #                    author='Debbie', title='Test', speed=65, time_signature=(4, 4), clef='f')#     # s, success, fail = composer(save_json=False)#     # s.export_to_file('test.musicxml')#     # s.to_xml(pretty_print=True)#     p1 = PhaseOne("/Users/daipeiyuan/Desktop/1.jpeg")#     p1.run()